{"version":3,"file":"generate-patched-file.js","sourceRoot":"","sources":["../../src/eslint-bulk-suppressions/generate-patched-file.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport fs from 'fs';\n\n/**\n * Dynamically generate file to properly patch many versions of ESLint\n * @param inputFilePath Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js\n * @param outputFilePath Some small changes to linter.js\n */\nexport function generatePatchedFileIfDoesntExist(inputFilePath: string, outputFilePath: string): void {\n  if (fs.existsSync(outputFilePath)) {\n    return;\n  }\n\n  const inputFile = fs.readFileSync(inputFilePath).toString();\n\n  let inputIndex = 0;\n\n  /**\n   * Extract from the stream until marker is reached.  When matching marker,\n   * ignore whitespace in the stream and in the marker.  Return the extracted text.\n   */\n  function scanUntilMarker(marker: string): string {\n    const trimmedMarker = marker.replace(/\\s/g, '');\n\n    let output = '';\n    let trimmed = '';\n\n    while (inputIndex < inputFile.length) {\n      const char = inputFile[inputIndex++];\n      output += char;\n      if (!/^\\s$/.test(char)) {\n        trimmed += char;\n      }\n      if (trimmed.endsWith(trimmedMarker)) {\n        return output;\n      }\n    }\n\n    throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));\n  }\n\n  function scanUntilNewline(): string {\n    let output = '';\n\n    while (inputIndex < inputFile.length) {\n      const char = inputFile[inputIndex++];\n      output += char;\n      if (char === '\\n') {\n        return output;\n      }\n    }\n\n    throw new Error('Unexpected end of input while looking for new line');\n  }\n\n  function scanUntilEnd(): string {\n    const output = inputFile.substring(inputIndex);\n    inputIndex = inputFile.length;\n    return output;\n  }\n\n  /**\n   * Returns index of next public method\n   * @param {number} fromIndex index of inputFile to search if public method still exists\n   * @returns {number} -1 if public method does not exist or index of next public method\n   */\n  function getIndexOfNextPublicMethod(fromIndex: number): number {\n    const rest = inputFile.substring(fromIndex);\n\n    const endOfClassIndex = rest.indexOf('\\n}');\n\n    const markerForStartOfClassMethod = '\\n     */\\n    ';\n\n    const startOfClassMethodIndex = rest.indexOf(markerForStartOfClassMethod);\n\n    if (startOfClassMethodIndex === -1 || startOfClassMethodIndex > endOfClassIndex) {\n      return -1;\n    }\n\n    let afterMarkerIndex = rest.indexOf(markerForStartOfClassMethod) + markerForStartOfClassMethod.length;\n\n    const isPublicMethod =\n      rest[afterMarkerIndex] !== '_' &&\n      rest[afterMarkerIndex] !== '#' &&\n      !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('static') &&\n      !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('constructor');\n\n    if (isPublicMethod) {\n      return fromIndex + afterMarkerIndex;\n    }\n\n    return getIndexOfNextPublicMethod(fromIndex + afterMarkerIndex);\n  }\n\n  /**\n   * @param {number} indexToScanTo\n   * @returns {string}\n   */\n  function scanUntilIndex(indexToScanTo: number): string {\n    const output = inputFile.substring(inputIndex, indexToScanTo);\n    inputIndex = indexToScanTo;\n    return output;\n  }\n\n  let outputFile = '';\n\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Requirements\n  //    //------------------------------------------------------------------------------\n  outputFile += scanUntilMarker('// Requirements');\n  outputFile += scanUntilMarker('//--');\n  outputFile += scanUntilNewline();\n\n  outputFile += `\n// --- BEGIN MONKEY PATCH ---\nconst bulkSuppressionsPatch = require('../../bulk-suppressions-patch');\nconst requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;\n`;\n\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Typedefs\n  //    //------------------------------------------------------------------------------\n  const requireSection = scanUntilMarker('// Typedefs');\n\n  // Match something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = require('eslint-scope'),\n  //    evk = require('eslint-visitor-keys'),\n  //\n  // Convert to something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = requireFromPathToLinterJS('eslint-scope'),\n  //    evk = requireFromPathToLinterJS('eslint-visitor-keys'),\n  //\n  outputFile += requireSection.replace(/require\\s*\\((?:'([^']+)'|\"([^\"]+)\")\\)/g, (match, p1, p2) => {\n    const importPath = p1 ?? p2 ?? '';\n\n    if (importPath !== 'path') {\n      if (p1) {\n        return `requireFromPathToLinterJS('${p1}')`;\n      }\n      if (p2) {\n        return `requireFromPathToLinterJS(\"${p2}\")`;\n      }\n    }\n\n    // Keep as-is\n    return match;\n  });\n  outputFile += `--- END MONKEY PATCH ---\n`;\n\n  // Match this:\n  //    const ruleContext = Object.freeze(\n  //      Object.assign(Object.create(sharedTraversalContext), {\n  //        id: ruleId,\n  //        options: getRuleOptions(configuredRules[ruleId]),\n  //        report(...args) {\n  //          /*\n  //           * Create a report translator lazily.\n  //\n  // Convert to something like this:\n  //\n  //    const ruleContext = Object.freeze(\n  //      Object.assign(Object.create(sharedTraversalContext), {\n  //        id: ruleId,\n  //        options: getRuleOptions(configuredRules[ruleId]),\n  //        report(...args) {\n  //          if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;\n  //          /*\n  //           * Create a report translator lazily.\n  //\n  outputFile += scanUntilMarker('const ruleContext = Object.freeze(');\n  outputFile += scanUntilMarker('report(...args) {');\n  outputFile += scanUntilNewline();\n  outputFile += `\n                        // --- BEGIN MONKEY PATCH ---\n                        if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;\n                        // --- END MONKEY PATCH ---\n`;\n\n  // Match this:\n  // nodeQueue.forEach((traversalInfo) => {\n  //   currentNode = traversalInfo.node;\n  //\n  //   try {\n  //     if (traversalInfo.isEntering) {\n  //       eventGenerator.enterNode(currentNode);\n  //     } else {\n  //       eventGenerator.leaveNode(currentNode);\n  //     }\n  //   } catch (err) {\n  //     err.currentNode = currentNode;\n  //     throw err;\n  //   }\n  // });\n  //\n  // return lintingProblems;\n  //\n  // Convert to this:\n  // nodeQueue.forEach((traversalInfo) => {\n  //   currentNode = traversalInfo.node;\n  //\n  //   try {\n  //     if (traversalInfo.isEntering) {\n  //       eventGenerator.enterNode(currentNode);\n  //     } else {\n  //       eventGenerator.leaveNode(currentNode);\n  //     }\n  //   } catch (err) {\n  //     err.currentNode = currentNode;\n  //     throw err;\n  //   }\n  // });\n  //\n  // // --- BEGIN MONKEY PATCH ---\n  // bulkSuppressionsPatch.onFinish({ filename });\n  // // --- END MONKEY PATCH ---\n  //\n  // return lintingProblems;\n  outputFile += scanUntilMarker('nodeQueue.forEach(traversalInfo => {');\n  outputFile += scanUntilMarker('});');\n  outputFile += scanUntilNewline();\n  outputFile += `\n    // --- BEGIN MONKEY PATCH ---\n    bulkSuppressionsPatch.onFinish({ filename });\n    // --- END MONKEY PATCH ---\n`;\n\n  outputFile += scanUntilMarker('class Linter {');\n  outputFile += scanUntilNewline();\n  outputFile += `\n    // --- BEGIN MONKEY PATCH ---\n    /**\n     * We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is\n     * initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all\n     * the patched methods refer to is not initialized. This method checks if the internalSlotsMap is\n     * initialized, and if not, initializes it.\n     */\n    _conditionallyReinitialize({ cwd, configType } = {}) {\n        if (internalSlotsMap.get(this) === undefined) {\n            internalSlotsMap.set(this, {\n              cwd: normalizeCwd(cwd),\n              lastConfigArray: null,\n              lastSourceCode: null,\n              lastSuppressedMessages: [],\n              configType, // TODO: Remove after flat config conversion\n              parserMap: new Map([['espree', espree]]),\n              ruleMap: new Rules()\n            });\n\n            this.version = pkg.version;\n        }\n    }\n    // --- END MONKEY PATCH ---\n`;\n\n  let indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n  while (indexOfNextPublicMethod !== -1) {\n    outputFile += scanUntilIndex(indexOfNextPublicMethod);\n    outputFile += scanUntilNewline();\n    outputFile += `        // --- BEGIN MONKEY PATCH ---\n        this._conditionallyReinitialize();\n        // --- END MONKEY PATCH ---\n`;\n    indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n  }\n\n  outputFile += scanUntilEnd();\n\n  fs.writeFileSync(outputFilePath, outputFile);\n}\n"]}